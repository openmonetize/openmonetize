// API Gateway - Unified entry point for OpenMonetize Platform
import Fastify from 'fastify';
import cors from '@fastify/cors';
import helmet from '@fastify/helmet';
import rateLimit from '@fastify/rate-limit';
import swagger from '@fastify/swagger';
import swaggerUi from '@fastify/swagger-ui';
import { config } from './config';
import { logger } from './logger';
import { getPrismaClient } from '@openmonetize/common';
import Redis from 'ioredis';

// Import routes
import { healthRoutes } from './routes/health';
import { customersRoutes } from './routes/customers';
import { ingestionRoutes } from './routes/ingestion';
import { ratingRoutes } from './routes/rating';
import { creditsRoutes } from './routes/credits';
import { entitlementsRoutes } from './routes/entitlements';
import { analyticsRoutes } from './routes/analytics';
import { demoRoutes } from './routes/demo';

const db = getPrismaClient();
const redis = new Redis(config.redis.url);

export async function buildApp() {
  const app = Fastify({
    logger: {
      level: 'info'
    },
    requestIdLogLabel: 'reqId',
    disableRequestLogging: false,
    requestIdHeader: 'x-request-id',
    bodyLimit: 10485760, // 10MB
  });

  // Register CORS
  await app.register(cors, {
    origin: config.cors.origin,
    credentials: true,
  });

  // Register security headers
  await app.register(helmet, {
    contentSecurityPolicy: false,
  });

  // Register rate limiting (Redis-backed)
  await app.register(rateLimit, {
    max: config.rateLimit.max,
    timeWindow: config.rateLimit.timeWindow,
    redis,
    keyGenerator: (request) => {
      // Rate limit by API key (customer ID)
      // Try Authorization: Bearer header first
      const authHeader = request.headers.authorization;
      if (authHeader && authHeader.startsWith('Bearer ')) {
        return authHeader.substring(7);
      }
      // Try X-API-Key header
      const apiKeyHeader = request.headers['x-api-key'];
      if (typeof apiKeyHeader === 'string') {
        return apiKeyHeader;
      }
      // Fallback to IP address
      return request.ip;
    },
  });

  // Register Swagger documentation
  await app.register(swagger, {
    openapi: {
      info: {
        title: config.swagger.title,
        description: `${config.swagger.description}

## ‚ö†Ô∏è Important: About "default" Category

The **"default"** section at the bottom contains HTTP proxy infrastructure routes (wildcards for all HTTP methods). These are automatically generated by the API Gateway's proxy layer and **should be ignored**.

**Instead, use the specific endpoints documented in each category above.** Only the endpoints explicitly listed in the category descriptions are actually implemented.

## Authentication

All API endpoints require authentication using Bearer token format:

\`\`\`
Authorization: Bearer YOUR_API_KEY
\`\`\`

Or using the X-API-Key header:

\`\`\`
X-API-Key: YOUR_API_KEY
\`\`\``,
        version: config.swagger.version,
      },
      servers: [
        {
          url: `http://localhost:${config.port}`,
          description: 'Development server',
        },
      ],
      tags: [
        {
          name: 'Health',
          description: 'Health check endpoints'
        },
        {
          name: 'Events',
          description: `Event ingestion (proxied to ingestion service)

**Available Endpoints:**
- \`POST /v1/events/ingest\` - Ingest batch of usage events
- \`GET /v1/events/dlq\` - Get Dead Letter Queue items (failed events)
- \`POST /v1/events/dlq/replay\` - Replay failed events from DLQ
- \`GET /v1/events/info\` - Get service information

**Note:** The wildcard routes shown below are proxy routes. Only the specific endpoints above are implemented.`
        },
        {
          name: 'Rating',
          description: `Cost calculation (proxied to rating engine)

**Available Endpoints:**
- \`POST /v1/rating/calculate\` - Calculate cost for single operation
- \`POST /v1/rating/bulk-calculate\` - Calculate costs for multiple operations

**Note:** The wildcard routes shown below are proxy routes. Only the specific endpoints above are implemented.`
        },
        {
          name: 'Burn Tables',
          description: `Pricing configuration (proxied to rating engine)

**Available Endpoints:**
- \`GET /v1/burn-tables\` - List all burn tables
- \`GET /v1/burn-tables/:id\` - Get specific burn table
- \`POST /v1/burn-tables\` - Create new burn table
- \`PUT /v1/burn-tables/:id\` - Update burn table
- \`DELETE /v1/burn-tables/:id\` - Delete burn table

**Note:** The wildcard routes shown below are proxy routes. Only the specific endpoints above are implemented.`
        },
        {
          name: 'Analytics',
          description: `Usage and cost analytics

**Direct Endpoints (API Gateway):**
- \`GET /v1/analytics/usage\` - Get detailed usage analytics by feature, provider, and timeline
- \`GET /v1/analytics/costs\` - Get cost breakdown and margin analysis
- \`GET /v1/analytics/burn-rate\` - Get credit burn rate and consumption trends

**Proxied Endpoints (Rating Engine):**
- \`GET /v1/analytics/cost-breakdown\` - Get cost breakdown by provider/model
- \`GET /v1/analytics/usage-trends\` - Get usage trends over time
- \`GET /v1/analytics/top-users\` - Get top users by usage/cost

**Note:** The wildcard routes shown under "default" are proxy infrastructure. Use the specific endpoints listed above.`
        },
        {
          name: 'Credits',
          description: 'Credit management'
        },
        {
          name: 'Entitlements',
          description: 'Feature access control'
        },
      ],
      components: {
        securitySchemes: {
          bearerAuth: {
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'API Key',
            description: 'API key authentication (Format: Bearer <your-api-key>)',
          },
        },
      },
      security: [
        {
          bearerAuth: [],
        },
      ],
    },
  });

  // Register Swagger UI
  await app.register(swaggerUi, {
    routePrefix: '/docs',
    uiConfig: {
      docExpansion: 'list',
      deepLinking: true,
    },
    staticCSP: true,
    transformStaticCSP: (header) => header,
  });

  // Register routes (order matters for proxies)
  await app.register(healthRoutes); // No prefix - health routes
  await app.register(customersRoutes); // Customer management (registration is public)
  await app.register(creditsRoutes); // Direct routes
  await app.register(entitlementsRoutes); // Direct routes
  await app.register(analyticsRoutes); // Direct routes
  await app.register(ingestionRoutes); // Proxy routes (must be after direct routes)
  await app.register(ratingRoutes); // Proxy routes (must be after direct routes)
  await app.register(demoRoutes); // Demo routes

  // Global error handler
  app.setErrorHandler((error, request, reply) => {
    logger.error({ err: error, reqId: request.id }, 'Request error');

    // Handle rate limit errors
    if (error.statusCode === 429) {
      return reply.status(429).send({
        error: 'Too Many Requests',
        message: 'Rate limit exceeded. Please try again later.',
      });
    }

    // Handle Fastify validation errors
    if (error.validation) {
      return reply.status(400).send({
        error: 'Validation Error',
        message: error.message,
        details: error.validation,
      });
    }

    // Generic error
    return reply.status(error.statusCode || 500).send({
      error: error.name || 'Internal Server Error',
      message: error.message || 'An unexpected error occurred',
    });
  });

  // Graceful shutdown
  const signals = ['SIGINT', 'SIGTERM'];
  for (const signal of signals) {
    process.on(signal, async () => {
      logger.info(`Received ${signal}, shutting down gracefully...`);
      await app.close();
      await db.$disconnect();
      await redis.quit();
      process.exit(0);
    });
  }

  return app;
}

async function start() {
  try {
    const app = await buildApp();

    // Test database connection
    await db.$queryRaw`SELECT 1`;
    logger.info('Database connection established');

    // Test Redis connection
    await redis.ping();
    logger.info('Redis connection established');

    // Start server
    await app.listen({
      port: config.port,
      host: config.host,
    });

    logger.info(`üöÄ API Gateway running on ${config.host}:${config.port}`);
    logger.info(`üìñ API Documentation: http://${config.host}:${config.port}/docs`);
  } catch (error) {
    logger.error({ err: error }, 'Failed to start server');
    process.exit(1);
  }
}

// Only run start if this file is the main module
// In ES modules, we check import.meta.url or similar, but here we are using tsx/node
// CommonJS check: require.main === module
// ESM check: process.argv[1] === fileURLToPath(import.meta.url)
// Since we use tsx, let's check if it's being run directly.
// A simple way is to check if we are being imported.
// But for now, let's just call start() if not imported.
// However, in ESM, detecting main module is tricky.
// We can export start and call it in a separate entry point, or just call it here.
// If we import this file, it will run start(). That's bad.
// We should move start() to a separate file or use a check.
// Let's assume we are running with tsx which supports CJS-style require.main === module if configured, or just use a separate entry point.
// But to avoid breaking existing scripts, I'll use a check.

// CommonJS check
if (require.main === module) {
  start();
}
